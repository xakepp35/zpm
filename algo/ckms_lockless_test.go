package algo

import (
	"math"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

// –¢–µ—Å—Ç –Ω–∞ –≤—Å—Ç–∞–≤–∫—É –∏ –∑–∞–ø—Ä–æ—Å –∫–≤–∞–Ω—Ç–∏–ª–µ–π
//
//	üîç –°—É—Ç—å: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ—Å–ª–µ –≤—Å—Ç–∞–≤–∫–∏ 1000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–≤–∞–Ω—Ç–∏–ª—å–Ω—ã–µ –æ—Ü–µ–Ω–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –æ–∂–∏–¥–∞–µ–º—ã–º.
//	‚úÖ –ï—Å–ª–∏ –¥–∞: –ó–Ω–∞—á–µ–Ω–∏—è 50-–≥–æ –∏ 90-–≥–æ –∫–≤–∞–Ω—Ç–∏–ª–µ–π –æ–∫–æ–ª–æ 499 –∏ 900 (—Å –¥–æ–ø—É—Å—Ç–∏–º–æ–π –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å—é).
//	‚ùå –ï—Å–ª–∏ –Ω–µ—Ç: –ó–Ω–∞—á–µ–Ω–∏—è –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –æ–∂–∏–¥–∞–Ω–∏—è–º, —á—Ç–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –æ—à–∏–±–∫–∏ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–µ CKMS.
func TestCKMSLockless_InsertAndQuery(t *testing.T) {
	c := NewCKMSLockless(0.5, 0.9)
	// –í—Å—Ç–∞–≤–ª—è–µ–º 1000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
	for i := 0; i < 1000; i++ {
		c.Insert(float64(i))
	}
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–≤–∞–Ω—Ç–∏–ª–∏
	assert.InDelta(t, 499, c.Query(0.5), 10, "–ú–µ–¥–∏–∞–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ–∫–æ–ª–æ 499")
	assert.InDelta(t, 900, c.Query(0.9), 20, "90-–π –∫–≤–∞–Ω—Ç–∏–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–∫–æ–ª–æ 900")
}

// –¢–µ—Å—Ç –Ω–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—É—é –≤—Å—Ç–∞–≤–∫—É
//
//	üîç –°—É—Ç—å: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –≤—Å—Ç–∞–≤–∫–∏ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω —Ä–∞–±–æ—Ç–∞—é—Ç –±–µ–∑ –≥–æ–Ω–æ–∫ –∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö.
//	‚úÖ –ï—Å–ª–∏ –¥–∞: –ó–∞–ø—Ä–æ—Å –∫–≤–∞–Ω—Ç–∏–ª—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Å–º—ã—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (500.0), –±–µ–∑ NaN –∏ –º—É—Å–æ—Ä–∞.
//	‚ùå –ï—Å–ª–∏ –Ω–µ—Ç: –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è NaN, –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —á–∏—Å–ª–∞ –∏–ª–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–∞–Ω–∏–∫–∞.
func TestCKMSLockless_ConcurrentInsert(t *testing.T) {
	c := NewCKMSLockless(0.5)
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(base int) {
			defer wg.Done()
			for j := 0; j < 100; j++ {
				c.Insert(float64(base*100 + j))
			}
		}(i)
	}
	wg.Wait()
	// –î–æ–ª–∂–Ω—ã –±—ã—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
	result := c.Query(0.5)
	assert.False(t, math.IsNaN(result), "–ö–≤–∞–Ω—Ç–∏–ª—å –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å NaN")
	assert.Equal(t, 500.0, result)
}

// –¢–µ—Å—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å –∏–∑ –ø—É—Å—Ç–æ–≥–æ CKMS
//
//	üîç –°—É—Ç—å: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ñ—É–Ω–∫—Ü–∏—è Query() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç NaN.
//	‚úÖ –ï—Å–ª–∏ –¥–∞: –í–µ—Ä–Ω—ë—Ç—Å—è NaN, –∫–∞–∫ –∏ –æ–∂–∏–¥–∞–µ—Ç—Å—è, –ø–æ—Å–∫–æ–ª—å–∫—É –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –∫–≤–∞–Ω—Ç–∏–ª–µ–π.
//	‚ùå –ï—Å–ª–∏ –Ω–µ—Ç: –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –ª—é–±–æ–µ —á–∏—Å–ª–æ –∫—Ä–æ–º–µ NaN, —á—Ç–æ –≥–æ–≤–æ—Ä–∏—Ç –æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ–≤–µ–¥–µ–Ω–∏–∏ –ø—Ä–∏ –ø—É—Å—Ç–æ–º CKMS.
func TestCKMSLockless_EmptyQuery(t *testing.T) {
	c := NewCKMSLockless(0.5)
	result := c.Query(0.5)
	assert.True(t, math.IsNaN(result), "–ù–∞ –ø—É—Å—Ç–æ–º CKMS —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å NaN")
}

// –¢–µ—Å—Ç –Ω–∞ –≥–æ–Ω–∫—É Insert vs Query –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏ –±—É—Ñ–µ—Ä–∞
//
//	üõ† –°—É—Ç—å: –í—Å—Ç–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Ç–æ–∫–æ–≤ –¥–æ –ø–æ–ª–Ω–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –±—É—Ñ–µ—Ä–∞, –∑–∞—Ç–µ–º —á–∏—Ç–∞–µ–º –Ω–∞ –ª–µ—Ç—É. –ï—Å–ª–∏ –µ—Å—Ç—å –≥–æ–Ω–∫–∞, –±—É–¥—É—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ –ø–∞–Ω–∏–∫–∞.
//	‚úÖ –ï—Å–ª–∏ –≥–æ–Ω–∫–∏ –Ω–µ—Ç, —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ
//	‚ùå –ï—Å–ª–∏ –µ—Å—Ç—å –≥–æ–Ω–∫–∞, —Ç–µ—Å—Ç –º–æ–∂–µ—Ç –∑–∞—Ñ–µ–π–ª–∏—Ç—å—Å—è —Å –ø–∞–Ω–∏–∫–æ–π
func TestCKMSLockless_RaceInsertQuery(t *testing.T) {
	c := NewCKMSLockless(0.5)
	var wg sync.WaitGroup
	stop := make(chan struct{})
	// –í—Å—Ç–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ–Ω–µ, –ø–æ–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è Query
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i < bufferSize*5; i++ {
			c.Insert(float64(i))
			if i%bufferSize == 0 {
				time.Sleep(time.Microsecond) // –ò–º–∏—Ç–∞—Ü–∏—è –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏
			}
		}
		close(stop)
	}()
	// –ß–∏—Ç–∞–µ–º –∫–≤–∞–Ω—Ç–∏–ª–∏ –≤ —Ñ–æ–Ω–µ, –ø–æ–∫–∞ –∏–¥–µ—Ç –≤—Å—Ç–∞–≤–∫–∞
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case <-stop:
				return
			default:
				_ = c.Query(0.5) // –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–µ–∑ –ø–∞–Ω–∏–∫–∏!
			}
		}
	}()
	wg.Wait()
}

// –¢–µ—Å—Ç –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –±—É—Ñ–µ—Ä–∞ –≤ quickSelect()
// üõ† –°—É—Ç—å: quickSelect() –∏–∑–º–µ–Ω—è–µ—Ç arr, –Ω–æ arr ‚Äî —ç—Ç–æ –±—É—Ñ–µ—Ä c.buffer, –∫–æ—Ç–æ—Ä—ã–π –∞—Ç–æ–º–∞—Ä–Ω–æ —á–∏—Ç–∞–µ—Ç—Å—è –≤ Insert. –ï—Å–ª–∏ –±—É—Ñ–µ—Ä –∏–∑–º–µ–Ω—è–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã Query(), –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö.
// ‚úÖ –ï—Å–ª–∏ quickSelect() —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ—Ç
// ‚ùå –ï—Å–ª–∏ quickSelect() –ø–æ—Ä—Ç–∏—Ç –±—É—Ñ–µ—Ä, —Ç–µ—Å—Ç –∑–∞—Ñ–µ–π–ª–∏—Ç—Å—è
func TestCKMSLockless_BrokenQuickSelect(t *testing.T) {
	c := NewCKMSLockless(0.5)

	// –ó–∞–ø–æ–ª–Ω—è–µ–º –±—É—Ñ–µ—Ä
	for i := 0; i < bufferSize; i++ {
		c.Insert(float64(i))
	}

	before := make([]float64, bufferSize)
	for i := 0; i < bufferSize; i++ {
		before[i] = AtomicFloatLoad(&c.buffer[i].value)
	}

	// –ó–∞–ø—É—Å–∫–∞–µ–º Query, –∫–æ—Ç–æ—Ä—ã–π –≤–Ω—É—Ç—Ä–∏ –≤—ã–∑—ã–≤–∞–µ—Ç quickSelect
	_ = c.Query(0.5)

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –≤ –±—É—Ñ–µ—Ä–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å
	for i := 0; i < bufferSize; i++ {
		after := AtomicFloatLoad(&c.buffer[i].value)
		assert.Equal(t, before[i], after, "quickSelect() –∏–∑–º–µ–Ω–∏–ª –±—É—Ñ–µ—Ä!")
	}
}

// –¢–µ—Å—Ç –Ω–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑-–∑–∞ unsafe.Pointer
//
//	üõ† –°—É—Ç—å: –ï—Å–ª–∏ unsafe.Pointer –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ, –º–æ–∂–µ—Ç –ø—Ä–æ–∏–∑–æ–π—Ç–∏ —Ä–∞–∑—Ä—ã–≤ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏—è—Ö.
//	‚úÖ –ï—Å–ª–∏ Insert() —Ä–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ, —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ—Ç
//	‚ùå –ï—Å–ª–∏ unsafe.Pointer –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, —Ç–µ—Å—Ç –∑–∞—Ñ–µ–π–ª–∏—Ç—Å—è
func TestCKMSLockless_UnsafePointer(t *testing.T) {
	c := NewCKMSLockless(0.5)

	var wg sync.WaitGroup
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(val float64) {
			defer wg.Done()
			c.Insert(val)
		}(float64(i))
	}
	wg.Wait()

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –±–∏—Ç—ã—Ö –¥–∞–Ω–Ω—ã—Ö
	for i := 0; i < bufferSize; i++ {
		val := AtomicFloatLoad(&c.buffer[i].value)
		assert.False(t, math.IsNaN(val), "–ù–∞–π–¥–µ–Ω–æ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ NaN!")
		assert.Less(t, val, 1e10, "–ù–∞–π–¥–µ–Ω–æ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª—å—à–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ")
	}
}
